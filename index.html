<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub PR Combiner</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
        }
        
        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* Two-column layout when file explorer is visible */
        .main-content-wrapper {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        
        .main-content {
            flex: 1;
            min-width: 0; /* Allows flex item to shrink below content size */
        }
        
        header {
            background: #24292e;
            color: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
        }
        
        header h1 {
            margin-bottom: 10px;
        }
        
        .auth-section {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .auth-section label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .auth-section input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .auth-section button {
            background: #2ea44f;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }
        
        .auth-section button:hover {
            background: #2c974b;
        }
        
        .auth-section .status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
        }
        
        .auth-section .status.success {
            background: #d4edda;
            color: #155724;
        }
        
        .auth-section .status.error {
            background: #f8d7da;
            color: #721c24;
        }
        
        .pr-form {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .pr-form h2 {
            margin-bottom: 15px;
        }
        
        .pr-form label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .pr-form input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .pr-form .help-text {
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
        }
        
        .pr-form button {
            background: #0366d6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            margin-right: 10px;
        }
        
        .pr-form button:hover {
            background: #0256c7;
        }
        
        .pr-list {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .pr-list h2 {
            margin-bottom: 15px;
        }
        
        .pr-item {
            display: flex;
            align-items: center;
            padding: 10px;
            background: #f6f8fa;
            margin-bottom: 8px;
            border-radius: 4px;
        }
        
        .pr-item span {
            flex: 1;
            font-family: monospace;
            font-size: 14px;
        }
        
        .pr-item a {
            margin-right: 10px;
            color: #0366d6;
            text-decoration: none;
            font-weight: 600;
            font-size: 14px;
        }
        
        .pr-item a:hover {
            text-decoration: underline;
        }
        
        .pr-item .pr-name-link {
            font-family: monospace;
            font-weight: 400;
            min-width: 40%;
            display: inline-block;
        }
        
        .pr-item .approval-badge {
            margin-left: 10px;
            margin-right: 10px;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .pr-item .approval-badge.approved {
            background: #d4edda;
            color: #155724;
        }
        
        .pr-item .approval-badge.not-approved {
            background: #f8f9fa;
            color: #666;
        }
        
        .pr-item button {
            background: #d73a49;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .pr-item button:hover {
            background: #cb2431;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .loading::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }
        
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
        
        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        
        .pr-section {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .pr-header {
            border-bottom: 2px solid #e1e4e8;
            padding-bottom: 15px;
            margin-bottom: 20px;
        }
        
        .pr-header h2 {
            color: #0366d6;
            margin-bottom: 8px;
        }
        
        .pr-meta {
            font-size: 14px;
            color: #666;
        }
        
        .pr-meta span {
            margin-right: 15px;
        }
        
        .diff-container {
            margin-top: 20px;
        }
        
        .no-prs {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        
        .comments-section {
            margin-top: 30px;
            border-top: 2px solid #e1e4e8;
            padding-top: 20px;
        }
        
        .comments-section h3 {
            margin-bottom: 15px;
            color: #24292e;
        }
        
        .comment-item {
            background: #f6f8fa;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
            position: relative;
        }
        
        .comment-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .comment-author {
            font-weight: 600;
            margin-right: 10px;
        }
        
        .comment-date {
            color: #666;
            font-size: 12px;
            flex: 1;
        }
        
        .comment-hide-btn {
            background: #6a737d;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            margin-left: 10px;
        }
        
        .comment-hide-btn:hover {
            background: #586069;
        }
        
        .comment-body {
            line-height: 1.6;
            color: #24292e;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .comment-form {
            background: #f6f8fa;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .comment-form textarea {
            width: 100%;
            min-height: 100px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            font-size: 14px;
            resize: vertical;
            margin-bottom: 10px;
        }
        
        .comment-form button {
            background: #2ea44f;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            margin-right: 10px;
        }
        
        .comment-form button:hover {
            background: #2c974b;
        }
        
        .comment-form button.approve-btn {
            background: #0366d6;
        }
        
        .comment-form button.approve-btn:hover {
            background: #0256c7;
        }
        
        .no-comments {
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
        }
        
        .action-buttons {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e1e4e8;
        }
        
        .action-buttons button {
            background: #0366d6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            margin-right: 10px;
        }
        
        .action-buttons button:hover {
            background: #0256c7;
        }
        
        .action-buttons button.approve-btn {
            background: #2ea44f;
        }
        
        .action-buttons button.approve-btn:hover {
            background: #2c974b;
        }
        
        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }
        
        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }
        
        .comment-item.hidden {
            display: none;
        }
        
        .comment-item.resolved-comment {
            /* Will be hidden by default but can be shown via toggle */
        }
        
        .comment-item.manually-hidden .comment-body {
            display: none;
        }
        
        .comment-item.manually-hidden {
            background: #f1f3f5;
            padding: 10px 15px;
        }
        
        .comments-filter {
            margin-bottom: 15px;
            padding: 10px;
            background: #f6f8fa;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .comments-filter label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
            cursor: pointer;
        }
        
        .comments-filter input[type="checkbox"] {
            cursor: pointer;
        }
        
        .user-approval-status {
            background: #d4edda;
            color: #155724;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        .jump-to-top {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #0366d6;
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s;
        }
        
        .jump-to-top:hover {
            background: #0256c7;
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
        }
        
        .pr-general-status {
            margin-left: 10px;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }
        
        .pr-general-status.approved-state {
            background: #d4edda;
            color: #155724;
        }
        
        .pr-general-status.mixed-state {
            background: #fff3cd;
            color: #856404;
        }
        
        .pr-general-status.no-reviews {
            background: #f8f9fa;
            color: #666;
        }
        
        .pr-state-badge {
            margin-left: 10px;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .pr-state-badge.open {
            background: #dcffe4;
            color: #0e6027;
        }
        
        .pr-state-badge.merged {
            background: #e1e4e8;
            color: #6a737d;
        }
        
        .pr-state-badge.closed {
            background: #ffeef0;
            color: #d73a49;
        }
        
        /* File Explorer Styles */
        .file-explorer {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: none; /* Hidden until PRs are loaded */
            width: 20%;
            flex-shrink: 0;
            position: sticky;
            top: 20px;
            max-height: calc(100vh - 40px);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .file-explorer h2 {
            margin-bottom: 15px;
            color: #24292e;
            font-size: 16px;
        }
        
        .file-explorer-content {
            flex: 1;
            overflow-y: auto;
            border: 1px solid #e1e4e8;
            border-radius: 4px;
            padding: 10px;
            background: #f6f8fa;
        }
        
        .file-tree {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .file-tree-folder {
            margin: 5px 0;
        }
        
        .file-tree-folder-header {
            display: flex;
            align-items: center;
            padding: 5px 8px;
            cursor: pointer;
            border-radius: 4px;
            font-weight: 600;
            color: #24292e;
            user-select: none;
            word-wrap: break-word;
            overflow-wrap: break-word;
            background: white;
        }
        
        .file-tree-folder-header:hover {
            background: #e1e4e8;
        }
        
        .file-tree-folder-toggle {
            display: inline-block;
            width: 16px;
            margin-right: 5px;
            text-align: center;
            transition: transform 0.2s;
            flex-shrink: 0;
        }
        
        .file-tree-folder-name {
            flex: 1;
            word-wrap: break-word;
            overflow-wrap: break-word;
            min-width: 0;
        }
        
        .file-tree-folder.collapsed .file-tree-folder-toggle {
            transform: rotate(-90deg);
        }
        
        .file-tree-folder-children {
            margin-left: 20px;
            list-style: none;
            padding: 0;
        }
        
        .file-tree-folder.collapsed .file-tree-folder-children {
            display: none;
        }
        
        .file-tree-file {
            display: flex;
            align-items: center;
            padding: 5px 8px;
            margin: 2px 0;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
            font-size: 13px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            background: white;
        }
        
        .file-tree-file:hover {
            background: #e1e4e8;
        }
        
        .file-tree-file-icon {
            margin-right: 8px;
            color: #666;
            flex-shrink: 0;
        }
        
        .file-tree-file-name {
            flex: 1;
            color: #0366d6;
            word-wrap: break-word;
            overflow-wrap: break-word;
            min-width: 0;
        }
        
        .file-tree-file-badge {
            margin-left: 8px;
            padding: 2px 6px;
            background: #0366d6;
            color: white;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
        }
        
        .file-tree-file-prs {
            margin-left: 8px;
            font-size: 11px;
            color: #666;
        }
        
        .file-stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
            padding: 10px;
            background: #f6f8fa;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .file-stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .file-stat-label {
            font-weight: 600;
            color: #24292e;
        }
        
        .file-stat-value {
            color: #666;
            font-weight: 600;
        }
        
        /* PR selector for file explorer */
        .pr-section-header {
            margin: 20px 0 10px 0;
            padding: 8px 10px;
            background: #0366d6;
            color: white;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .pr-section-header:first-child {
            margin-top: 0;
        }
        
        .pr-section-header:hover {
            background: #0256c7;
        }
        
        .pr-section-toggle {
            display: inline-block;
            width: 16px;
            text-align: center;
            transition: transform 0.2s;
            flex-shrink: 0;
        }
        
        .pr-section.collapsed .pr-section-toggle {
            transform: rotate(-90deg);
        }
        
        .pr-section.collapsed .pr-file-tree {
            display: none;
        }
        
        .pr-file-tree {
            display: block;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîÄ GitHub PR Combiner</h1>
            <p>Combine multiple GitHub Pull Requests for review</p>
        </header>

        <div class="auth-section">
            <label for="pat-input">GitHub Personal Access Token</label>
            <input 
                type="password" 
                id="pat-input" 
                placeholder="ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
                autocomplete="off"
            >
            <button onclick="savePAT()">Save Token</button>
            <button onclick="clearPAT()" style="background: #d73a49;">Clear Token</button>
            <div id="auth-status"></div>
        </div>

        <div class="pr-form">
            <h2>Add Pull Request</h2>
            <label for="pr-url-input">PR URL or path</label>
            <input 
                type="text" 
                id="pr-url-input" 
                placeholder="https://github.com/owner/repo/pull/123 or owner/repo/pull/123"
            >
            <div class="help-text">
                Enter a GitHub PR URL or path in the format: owner/repo/pull/number
            </div>
            <button onclick="addPR()">Add PR</button>
            <button onclick="loadPRs()" style="background: #2ea44f;">Load PRs</button>
        </div>

        <div class="pr-list">
            <h2>Current PRs</h2>
            <div id="pr-list-container">
                <div class="no-prs">No PRs added yet</div>
            </div>
        </div>

        <div class="main-content-wrapper">
            <div id="file-explorer" class="file-explorer">
                <h2>üìÅ Files</h2>
                <div class="file-stats">
                    <div class="file-stat-item">
                        <span class="file-stat-label">Files:</span>
                        <span class="file-stat-value" id="total-files-count">0</span>
                    </div>
                    <div class="file-stat-item">
                        <span class="file-stat-label">Dirs:</span>
                        <span class="file-stat-value" id="total-dirs-count">0</span>
                    </div>
                    <div class="file-stat-item">
                        <span class="file-stat-label">PRs:</span>
                        <span class="file-stat-value" id="total-prs-count">0</span>
                    </div>
                </div>
                <div class="file-explorer-content" id="file-explorer-content">
                </div>
            </div>

            <div class="main-content">
                <div id="loading-indicator" style="display: none;" class="loading">
                    Loading PR data
                </div>

                <div id="error-container"></div>
                <div id="pr-data-container"></div>
            </div>
        </div>
    </div>
    
    <!-- Jump to Top button -->
    <button class="jump-to-top" onclick="scrollToTop()" title="Jump to top" aria-label="Jump to top">
        ‚Üë
    </button>

    <script src="https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js"></script>
    <script>
        const PAT_KEY = 'github_pat';
        const HIDDEN_COMMENTS_KEY = 'hidden_comments';
        let prDataCache = null;
        
        // Security: HTML escape function to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Scroll to top function
        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }
        
        // Hidden comments management
        function getHiddenComments() {
            const stored = localStorage.getItem(HIDDEN_COMMENTS_KEY);
            return stored ? JSON.parse(stored) : {};
        }
        
        function saveHiddenComments(hiddenComments) {
            localStorage.setItem(HIDDEN_COMMENTS_KEY, JSON.stringify(hiddenComments));
        }
        
        function toggleCommentVisibility(prIndex, commentIndex) {
            const hiddenComments = getHiddenComments();
            const key = `${prIndex}-${commentIndex}`;
            
            if (hiddenComments[key]) {
                delete hiddenComments[key];
            } else {
                hiddenComments[key] = true;
            }
            
            saveHiddenComments(hiddenComments);
            
            // Update UI
            const commentElement = document.querySelector(`[data-pr-index="${prIndex}"][data-comment-index="${commentIndex}"]`);
            if (commentElement) {
                const hideBtn = commentElement.querySelector('.comment-hide-btn');
                if (hiddenComments[key]) {
                    commentElement.classList.add('manually-hidden');
                    hideBtn.textContent = 'Show';
                } else {
                    commentElement.classList.remove('manually-hidden');
                    hideBtn.textContent = 'Hide';
                }
            }
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            checkPATStatus();
            loadPRsFromURL();
        });

        // PAT Management
        function savePAT() {
            const pat = document.getElementById('pat-input').value.trim();
            if (!pat) {
                showAuthStatus('Please enter a valid token', 'error');
                return;
            }
            
            localStorage.setItem(PAT_KEY, pat);
            document.getElementById('pat-input').value = '';
            showAuthStatus('Token saved successfully!', 'success');
        }

        function clearPAT() {
            localStorage.removeItem(PAT_KEY);
            showAuthStatus('Token cleared', 'success');
        }

        function getPAT() {
            return localStorage.getItem(PAT_KEY);
        }

        function checkPATStatus() {
            const pat = getPAT();
            if (pat) {
                showAuthStatus('Token is saved ‚úì', 'success');
            } else {
                showAuthStatus('No token saved. Please add your GitHub PAT.', 'error');
            }
        }

        function showAuthStatus(message, type) {
            const statusDiv = document.getElementById('auth-status');
            statusDiv.className = 'status ' + type;
            statusDiv.textContent = message;
        }

        // PR URL Management
        function parsePRPath(input) {
            // Handle full URL: https://github.com/owner/repo/pull/123
            const urlMatch = input.match(/github\.com\/([^\/]+)\/([^\/]+)\/pull\/(\d+)/);
            if (urlMatch) {
                return `${urlMatch[1]}/${urlMatch[2]}/pull/${urlMatch[3]}`;
            }
            
            // Handle path format: owner/repo/pull/123
            const pathMatch = input.match(/^([^\/]+)\/([^\/]+)\/pull\/(\d+)$/);
            if (pathMatch) {
                return input;
            }
            
            return null;
        }

        function getPRsFromURL() {
            const params = new URLSearchParams(window.location.search);
            const prsParam = params.get('prs');
            if (!prsParam) return [];
            
            return prsParam.split(',').filter(pr => pr.trim());
        }

        function updateURL(prs) {
            const params = new URLSearchParams();
            if (prs.length > 0) {
                params.set('prs', prs.join(','));
            }
            
            const newURL = params.toString() 
                ? `${window.location.pathname}?${params.toString()}`
                : window.location.pathname;
            
            window.history.pushState({}, '', newURL);
        }

        function addPR() {
            const input = document.getElementById('pr-url-input').value.trim();
            if (!input) {
                alert('Please enter a PR URL or path');
                return;
            }

            const prPath = parsePRPath(input);
            if (!prPath) {
                alert('Invalid PR format. Use: owner/repo/pull/123');
                return;
            }

            const currentPRs = getPRsFromURL();
            if (currentPRs.includes(prPath)) {
                alert('This PR is already in the list');
                return;
            }

            currentPRs.push(prPath);
            updateURL(currentPRs);
            document.getElementById('pr-url-input').value = '';
            renderPRList();
        }

        function removePR(prPath) {
            const currentPRs = getPRsFromURL();
            const filtered = currentPRs.filter(pr => pr !== prPath);
            updateURL(filtered);
            renderPRList();
            
            // Clear PR data if we removed all PRs
            if (filtered.length === 0) {
                document.getElementById('pr-data-container').innerHTML = '';
            }
        }

        function renderPRList() {
            const prs = getPRsFromURL();
            const container = document.getElementById('pr-list-container');
            
            if (prs.length === 0) {
                container.innerHTML = '<div class="no-prs">No PRs added yet</div>';
                return;
            }

            // If we have cached PR data, show approval status
            let html = '';
            prs.forEach((pr, index) => {
                let approvalBadge = '';
                let generalStatusBadge = '';
                let stateBadge = '';
                let prUrl = `https://github.com/${pr}`; // Default URL constructed from PR path
                
                if (prDataCache && prDataCache[index]) {
                    const prData = prDataCache[index];
                    
                    // Use the actual PR URL from the cached data if available
                    if (prData.info.url) {
                        prUrl = prData.info.url;
                    }
                    
                    // PR State badge
                    const state = prData.info.state.toLowerCase();
                    stateBadge = `<span class="pr-state-badge ${state}">${prData.info.state}</span>`;
                    
                    // Calculate general PR status
                    let approvalCount = 0;
                    let changesRequestedCount = 0;
                    let viewerApproved = false;
                    
                    if (prData.info.reviews && prData.info.reviews.nodes) {
                        // Count approvals and changes requested
                        const reviewsByAuthor = {};
                        prData.info.reviews.nodes.forEach(review => {
                            // Keep only the latest review from each author
                            if (!reviewsByAuthor[review.author.login] || 
                                new Date(review.createdAt) > new Date(reviewsByAuthor[review.author.login].createdAt)) {
                                reviewsByAuthor[review.author.login] = review;
                            }
                        });
                        
                        Object.values(reviewsByAuthor).forEach(review => {
                            if (review.state === 'APPROVED') {
                                approvalCount++;
                            } else if (review.state === 'CHANGES_REQUESTED') {
                                changesRequestedCount++;
                            }
                        });
                        
                        if (prData.viewerLogin) {
                            viewerApproved = reviewsByAuthor[prData.viewerLogin]?.state === 'APPROVED';
                        }
                    }
                    
                    // User's personal approval status
                    if (viewerApproved) {
                        approvalBadge = '<span class="approval-badge approved">‚úì Approved</span>';
                    } else {
                        approvalBadge = '<span class="approval-badge not-approved">Not approved</span>';
                    }
                    
                    // General PR status
                    if (approvalCount > 0 || changesRequestedCount > 0) {
                        const approvalText = approvalCount > 0 ? `${approvalCount}‚úì` : '';
                        const changesText = changesRequestedCount > 0 ? `${changesRequestedCount}‚ö†` : '';
                        const separator = approvalText && changesText ? ' ' : '';
                        const statusClass = approvalCount > 0 && changesRequestedCount === 0 ? 'approved-state' : 
                                          (changesRequestedCount > 0 ? 'mixed-state' : 'no-reviews');
                        
                        generalStatusBadge = `<span class="pr-general-status ${statusClass}">${approvalText}${separator}${changesText}</span>`;
                    } else {
                        generalStatusBadge = '<span class="pr-general-status no-reviews">No reviews</span>';
                    }
                }
                
                html += `
                    <div class="pr-item">
                        <a href="#pr-${index}">Jump to PR</a>
                        <a href="${escapeHtml(prUrl)}" target="_blank" class="pr-name-link">${escapeHtml(pr)}</a>
                        ${stateBadge}
                        ${generalStatusBadge}
                        ${approvalBadge}
                        <button onclick="removePR('${escapeHtml(pr)}')">Remove</button>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        function loadPRsFromURL() {
            renderPRList();
        }

        // GitHub GraphQL API
        async function loadPRs() {
            const pat = getPAT();
            if (!pat) {
                showError('Please save your GitHub Personal Access Token first.');
                return;
            }

            const prs = getPRsFromURL();
            if (prs.length === 0) {
                showError('Please add at least one PR to load.');
                return;
            }

            document.getElementById('loading-indicator').style.display = 'block';
            document.getElementById('error-container').innerHTML = '';
            document.getElementById('pr-data-container').innerHTML = '';

            try {
                const prData = await fetchPRData(pat, prs);
                renderPRData(prData);
            } catch (error) {
                showError(`Error loading PRs: ${error.message}`);
            } finally {
                document.getElementById('loading-indicator').style.display = 'none';
            }
        }

        async function fetchPRData(pat, prPaths) {
            // Build GraphQL query with aliases for each PR
            const queries = prPaths.map((prPath, index) => {
                const parts = prPath.split('/');
                const owner = parts[0];
                const repo = parts[1];
                const number = parseInt(parts[3]);
                
                return `
                    pr${index}: repository(owner: "${owner}", name: "${repo}") {
                        pullRequest(number: ${number}) {
                            title
                            number
                            url
                            author {
                                login
                            }
                            baseRefName
                            headRefName
                            state
                            createdAt
                            updatedAt
                            additions
                            deletions
                            changedFiles
                            comments(first: 100) {
                                nodes {
                                    author {
                                        login
                                    }
                                    body
                                    createdAt
                                    updatedAt
                                }
                            }
                            reviews(first: 100) {
                                nodes {
                                    author {
                                        login
                                    }
                                    body
                                    state
                                    createdAt
                                }
                            }
                            reviewThreads(first: 100) {
                                nodes {
                                    isResolved
                                    comments(first: 100) {
                                        nodes {
                                            author {
                                                login
                                            }
                                            body
                                            path
                                            position
                                            originalPosition
                                            line
                                            originalLine
                                            createdAt
                                        }
                                    }
                                }
                            }
                        }
                    }
                `;
            });

            const query = `
                query {
                    viewer {
                        login
                    }
                    ${queries.join('\n')}
                }
            `;

            const response = await fetch('https://api.github.com/graphql', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${pat}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ query })
            });

            if (!response.ok) {
                throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
            }

            const result = await response.json();
            
            if (result.errors) {
                throw new Error(result.errors[0].message);
            }

            const viewerLogin = result.data.viewer ? result.data.viewer.login : null;

            // Fetch diffs for each PR
            const prDataWithDiffs = [];
            for (let i = 0; i < prPaths.length; i++) {
                const prData = result.data[`pr${i}`];
                if (!prData || !prData.pullRequest) {
                    throw new Error(`PR not found: ${prPaths[i]}`);
                }

                const parts = prPaths[i].split('/');
                const owner = parts[0];
                const repo = parts[1];
                const number = parseInt(parts[3]);
                
                const diff = await fetchPRDiff(pat, owner, repo, number);
                
                prDataWithDiffs.push({
                    path: prPaths[i],
                    info: prData.pullRequest,
                    diff: diff,
                    owner: owner,
                    repo: repo,
                    viewerLogin: viewerLogin
                });
            }

            return prDataWithDiffs;
        }

        async function fetchPRDiff(pat, owner, repo, number) {
            const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/pulls/${number}`, {
                headers: {
                    'Authorization': `Bearer ${pat}`,
                    'Accept': 'application/vnd.github.v3.diff'
                }
            });

            if (!response.ok) {
                throw new Error(`Failed to fetch diff: ${response.status}`);
            }

            return await response.text();
        }

        function renderPRData(prDataArray) {
            const container = document.getElementById('pr-data-container');
            container.innerHTML = '';
            
            // Cache the PR data for use in the PR list
            prDataCache = prDataArray;
            
            // Re-render the PR list to show approval status
            renderPRList();

            prDataArray.forEach((prData, index) => {
                const section = document.createElement('div');
                section.className = 'pr-section';
                section.id = `pr-${index}`;

                // Check if viewer has approved this PR
                let viewerApproved = false;
                let prHasApprovals = false;
                let approvalCount = 0;
                let changesRequestedCount = 0;
                
                if (prData.info.reviews && prData.info.reviews.nodes) {
                    // Count approvals and changes requested
                    const reviewsByAuthor = {};
                    prData.info.reviews.nodes.forEach(review => {
                        // Keep only the latest review from each author
                        if (!reviewsByAuthor[review.author.login] || 
                            new Date(review.createdAt) > new Date(reviewsByAuthor[review.author.login].createdAt)) {
                            reviewsByAuthor[review.author.login] = review;
                        }
                    });
                    
                    Object.values(reviewsByAuthor).forEach(review => {
                        if (review.state === 'APPROVED') {
                            approvalCount++;
                            prHasApprovals = true;
                        } else if (review.state === 'CHANGES_REQUESTED') {
                            changesRequestedCount++;
                        }
                    });
                    
                    if (prData.viewerLogin) {
                        viewerApproved = reviewsByAuthor[prData.viewerLogin]?.state === 'APPROVED';
                    }
                }

                const header = document.createElement('div');
                header.className = 'pr-header';
                
                let approvalBanner = '';
                if (viewerApproved) {
                    approvalBanner = '<div class="user-approval-status" style="margin-bottom: 15px;">‚úì You have approved this PR</div>';
                }
                
                // Add overall PR approval state
                let prStateBanner = '';
                if (approvalCount > 0 || changesRequestedCount > 0) {
                    const approvalText = approvalCount > 0 ? `${approvalCount} approval${approvalCount > 1 ? 's' : ''}` : '';
                    const changesText = changesRequestedCount > 0 ? `${changesRequestedCount} change${changesRequestedCount > 1 ? 's' : ''} requested` : '';
                    const separator = approvalText && changesText ? ', ' : '';
                    const stateColor = prHasApprovals && changesRequestedCount === 0 ? '#d4edda' : (changesRequestedCount > 0 ? '#fff3cd' : '#f8f9fa');
                    const textColor = prHasApprovals && changesRequestedCount === 0 ? '#155724' : (changesRequestedCount > 0 ? '#856404' : '#666');
                    
                    prStateBanner = `<div style="background: ${stateColor}; color: ${textColor}; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-weight: 600;">
                        PR Status: ${approvalText}${separator}${changesText}
                    </div>`;
                }
                
                header.innerHTML = `
                    <h2>${escapeHtml(prData.owner)}/${escapeHtml(prData.repo)} - ${escapeHtml(prData.info.title)} <a href="${escapeHtml(prData.info.url)}" target="_blank">#${prData.info.number}</a></h2>
                    ${prStateBanner}
                    ${approvalBanner}
                    <div class="pr-meta">
                        <span><strong>Author:</strong> ${escapeHtml(prData.info.author.login)}</span>
                        <span><strong>State:</strong> ${escapeHtml(prData.info.state)}</span>
                        <span><strong>Branch:</strong> ${escapeHtml(prData.info.headRefName)} ‚Üí ${escapeHtml(prData.info.baseRefName)}</span>
                        <span><strong>Changes:</strong> +${prData.info.additions} -${prData.info.deletions} (${prData.info.changedFiles} files)</span>
                    </div>
                `;

                const diffContainer = document.createElement('div');
                diffContainer.className = 'diff-container';
                diffContainer.id = `diff-${index}`;

                // Comments section
                const commentsSection = document.createElement('div');
                commentsSection.className = 'comments-section';
                commentsSection.innerHTML = renderComments(prData.info, index, prData.viewerLogin);

                // Comment form
                const commentForm = document.createElement('div');
                commentForm.className = 'comment-form';
                commentForm.innerHTML = `
                    <h4>Add a comment</h4>
                    <textarea id="comment-text-${index}" placeholder="Leave a comment..."></textarea>
                    <div id="comment-status-${index}"></div>
                    <button onclick="submitComment('${escapeHtml(prData.owner)}', '${escapeHtml(prData.repo)}', ${prData.info.number}, ${index})">Comment</button>
                    <button class="approve-btn" onclick="approvePR('${escapeHtml(prData.owner)}', '${escapeHtml(prData.repo)}', ${prData.info.number}, ${index})">Approve PR</button>
                `;

                section.appendChild(header);
                section.appendChild(diffContainer);
                section.appendChild(commentsSection);
                section.appendChild(commentForm);
                container.appendChild(section);

                // Render diff using diff2html
                try {
                    const diff2htmlUi = new Diff2HtmlUI(diffContainer, prData.diff, {
                        drawFileList: true,
                        matching: 'lines',
                        outputFormat: 'side-by-side',
                        synchronisedScroll: true,
                        highlight: true,
                        renderNothingWhenEmpty: false,
                    });
                    diff2htmlUi.draw();
                } catch (error) {
                    diffContainer.innerHTML = `<div class="error">Error rendering diff: ${error.message}</div>`;
                }
                
                // Show inline comments by default since checkbox is checked by default
                setTimeout(() => toggleInlineComments(index), 100);
            });
            
            // Build and render file explorer
            buildFileExplorer(prDataArray);
        }
        
        function buildFileExplorer(prDataArray) {
            const explorerContent = document.getElementById('file-explorer-content');
            explorerContent.innerHTML = '';
            
            let totalFiles = 0;
            let totalDirs = 0;
            
            // Build and display file tree for each PR
            prDataArray.forEach((prData, prIndex) => {
                // Extract files from this PR's diff
                const files = extractFilesFromDiff(prData.diff);
                const fileMap = new Map();
                files.forEach(filePath => {
                    fileMap.set(filePath, [prIndex]);
                });
                
                // Build directory tree for this PR
                const tree = buildDirectoryTree(fileMap);
                
                // Count for overall stats
                totalFiles += fileMap.size;
                totalDirs += countDirectories(tree);
                
                // Create PR section container
                const prSection = document.createElement('div');
                prSection.className = 'pr-section';
                prSection.id = `pr-section-${prIndex}`;
                
                // Create PR header
                const prHeader = document.createElement('div');
                prHeader.className = 'pr-section-header';
                prHeader.innerHTML = `
                    <span style="flex: 1; word-wrap: break-word; overflow-wrap: break-word; min-width: 0;">
                        ${escapeHtml(prData.owner)}/${escapeHtml(prData.repo)} - PR #${prData.info.number}: ${escapeHtml(prData.info.title)}
                    </span>
                    <span class="pr-section-toggle">‚ñº</span>
                `;
                prHeader.title = `${prData.owner}/${prData.repo} - PR #${prData.info.number}: ${prData.info.title}`;
                prHeader.onclick = () => togglePRSection(prIndex);
                
                // Create file tree container
                const treeContainer = document.createElement('div');
                treeContainer.className = 'pr-file-tree';
                treeContainer.id = `pr-tree-${prIndex}`;
                
                const treeList = document.createElement('ul');
                treeList.className = 'file-tree';
                
                // Render tree
                renderTreeNode(tree, treeList, fileMap, '', prIndex);
                
                treeContainer.appendChild(treeList);
                
                prSection.appendChild(prHeader);
                prSection.appendChild(treeContainer);
                explorerContent.appendChild(prSection);
            });
            
            // Update overall stats
            document.getElementById('total-files-count').textContent = totalFiles;
            document.getElementById('total-dirs-count').textContent = totalDirs;
            document.getElementById('total-prs-count').textContent = prDataArray.length;
            
            // Show the file explorer
            document.getElementById('file-explorer').style.display = 'flex';
        }
        
        function togglePRSection(prIndex) {
            const section = document.getElementById(`pr-section-${prIndex}`);
            section.classList.toggle('collapsed');
        }
        
        function extractFilesFromDiff(diffText) {
            const files = [];
            const lines = diffText.split('\n');
            
            for (let line of lines) {
                // Match diff file headers: diff --git a/path b/path
                if (line.startsWith('diff --git')) {
                    const match = line.match(/diff --git a\/(.*?) b\//);
                    if (match && match[1]) {
                        files.push(match[1]);
                    }
                }
            }
            
            return files;
        }
        
        function buildDirectoryTree(fileMap) {
            const tree = {};
            
            for (let filePath of fileMap.keys()) {
                const parts = filePath.split('/');
                let current = tree;
                
                // Build nested structure
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    const isFile = i === parts.length - 1;
                    
                    if (isFile) {
                        // It's a file
                        if (!current._files) {
                            current._files = [];
                        }
                        current._files.push(filePath);
                    } else {
                        // It's a directory
                        if (!current[part]) {
                            current[part] = {};
                        }
                        current = current[part];
                    }
                }
            }
            
            return tree;
        }
        
        function countDirectories(tree, count = 0) {
            for (let key in tree) {
                if (key !== '_files') {
                    count++;
                    count = countDirectories(tree[key], count);
                }
            }
            return count;
        }
        
        // Helper function to check if a directory node has only one subdirectory and no files
        function shouldCondensePath(node) {
            const keys = Object.keys(node).filter(k => k !== '_files');
            const files = node._files || [];
            return keys.length === 1 && files.length === 0;
        }
        
        // Helper function to get condensed path for a directory
        function getCondensedPath(node, baseName) {
            let path = [baseName];
            let current = node;
            
            while (shouldCondensePath(current)) {
                const nextKey = Object.keys(current).find(k => k !== '_files');
                path.push(nextKey);
                current = current[nextKey];
            }
            
            return {
                condensedPath: path.join('/'),
                finalNode: current
            };
        }
        
        function renderTreeNode(node, parentElement, fileMap, currentPath, prIndex) {
            // Get directories and files
            const directories = [];
            const files = node._files || [];
            
            for (let key in node) {
                if (key !== '_files') {
                    directories.push(key);
                }
            }
            
            // Sort directories and files
            directories.sort();
            
            // Render directories first
            directories.forEach(dir => {
                const dirPath = currentPath ? `${currentPath}/${dir}` : dir;
                
                // Check if this directory should be condensed
                const condensed = getCondensedPath(node[dir], dir);
                const displayName = condensed.condensedPath;
                const actualDirPath = currentPath ? `${currentPath}/${condensed.condensedPath}` : condensed.condensedPath;
                
                const li = document.createElement('li');
                li.className = 'file-tree-folder';
                
                const header = document.createElement('div');
                header.className = 'file-tree-folder-header';
                header.innerHTML = `
                    <span class="file-tree-folder-toggle">‚ñº</span>
                    <span class="file-tree-folder-name">üìÅ ${escapeHtml(displayName)}</span>
                `;
                
                header.onclick = function() {
                    li.classList.toggle('collapsed');
                };
                
                li.appendChild(header);
                
                const childrenUl = document.createElement('ul');
                childrenUl.className = 'file-tree-folder-children';
                renderTreeNode(condensed.finalNode, childrenUl, fileMap, actualDirPath, prIndex);
                li.appendChild(childrenUl);
                
                parentElement.appendChild(li);
            });
            
            // Render files
            files.sort().forEach(filePath => {
                const fileName = filePath.split('/').pop();
                
                const li = document.createElement('li');
                li.className = 'file-tree-file';
                
                li.innerHTML = `
                    <span class="file-tree-file-icon">üìÑ</span>
                    <span class="file-tree-file-name">${escapeHtml(fileName)}</span>
                `;
                
                li.onclick = function() {
                    navigateToFile(filePath, prIndex);
                };
                
                li.title = `${filePath} - Click to view in PR`;
                
                parentElement.appendChild(li);
            });
        }
        
        function navigateToFile(filePath, prIndex) {
            // First scroll to the PR section
            const prSection = document.getElementById(`pr-${prIndex}`);
            if (!prSection) return;
            
            // Scroll to PR
            prSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            
            // Try to find the specific file in the diff view
            setTimeout(() => {
                const diffContainer = document.getElementById(`diff-${prIndex}`);
                if (!diffContainer) return;
                
                // Look for the file in diff2html's rendered output
                const fileHeaders = diffContainer.querySelectorAll('.d2h-file-header');
                for (let header of fileHeaders) {
                    const fileNameSpan = header.querySelector('.d2h-file-name');
                    if (fileNameSpan && fileNameSpan.textContent.includes(filePath)) {
                        // Found it! Scroll to this file
                        header.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        
                        // Highlight the file briefly
                        const fileWrapper = header.closest('.d2h-file-wrapper');
                        if (fileWrapper) {
                            fileWrapper.style.outline = '3px solid #0366d6';
                            setTimeout(() => {
                                fileWrapper.style.outline = '';
                            }, 2000);
                        }
                        break;
                    }
                }
            }, 500);
        }
        
        function renderComments(prInfo, prIndex, viewerLogin) {
            const hiddenUsers = ['simonirwin-r7', 'compliance-r7', 'pd-sonarqube-r7', 'copilot-pull-request-reviewer', 'jenkins-eks-aicoe'];
            const hiddenComments = getHiddenComments();
            let html = '<h3>Comments and Reviews</h3>';
            
            // Add filter controls
            html += `
                <div class="comments-filter">
                    <label>
                        <input type="checkbox" id="hide-auto-${prIndex}" onchange="toggleHiddenComments(${prIndex})" checked>
                        Hide automated comments (simonirwin-r7, compliance-r7, pd-sonarqube-r7, copilot-pull-request-reviewer, jenkins-eks-aicoe)
                    </label>
                    <label>
                        <input type="checkbox" id="hide-resolved-${prIndex}" onchange="toggleResolvedComments(${prIndex})" checked>
                        Hide resolved threads
                    </label>
                    <label>
                        <input type="checkbox" id="show-inline-${prIndex}" onchange="toggleInlineComments(${prIndex})" checked>
                        Show inline comments with diffs
                    </label>
                </div>
            `;
            
            const allComments = [];
            const inlineComments = [];
            
            // Add issue comments
            if (prInfo.comments && prInfo.comments.nodes) {
                prInfo.comments.nodes.forEach(comment => {
                    allComments.push({
                        type: 'comment',
                        author: comment.author.login,
                        body: comment.body,
                        createdAt: comment.createdAt,
                        isHidden: hiddenUsers.includes(comment.author.login),
                        isResolved: false // Issue comments don't have resolved state
                    });
                });
            }
            
            // Add review comments (the review summary, not thread comments)
            if (prInfo.reviews && prInfo.reviews.nodes) {
                prInfo.reviews.nodes.forEach(review => {
                    if (review.body) {
                        allComments.push({
                            type: 'review',
                            author: review.author.login,
                            body: review.body,
                            state: review.state,
                            createdAt: review.createdAt,
                            isHidden: hiddenUsers.includes(review.author.login),
                            isResolved: false // Review summaries don't have resolved state
                        });
                    }
                });
            }
            
            // Add review thread comments
            if (prInfo.reviewThreads && prInfo.reviewThreads.nodes) {
                prInfo.reviewThreads.nodes.forEach(thread => {
                    const isResolved = thread.isResolved || false;
                    
                    if (thread.comments && thread.comments.nodes) {
                        thread.comments.nodes.forEach(comment => {
                            const threadComment = {
                                type: 'thread',
                                author: comment.author.login,
                                body: comment.body,
                                path: comment.path,
                                position: comment.position,
                                originalPosition: comment.originalPosition,
                                line: comment.line,
                                originalLine: comment.originalLine,
                                createdAt: comment.createdAt,
                                isHidden: hiddenUsers.includes(comment.author.login),
                                isResolved: isResolved
                            };
                            allComments.push(threadComment);
                            inlineComments.push(threadComment);
                        });
                    }
                });
            }
            
            // Sort by date
            allComments.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
            
            if (allComments.length === 0) {
                html += '<div class="no-comments">No comments yet</div>';
            } else {
                html += `<div id="comments-list-${prIndex}">`;
                allComments.forEach((comment, idx) => {
                    const date = new Date(comment.createdAt).toLocaleString();
                    let typeLabel = '';
                    
                    if (comment.type === 'review') {
                        typeLabel = ` <span style="color: #0366d6; font-weight: 600;">[${comment.state}]</span>`;
                    } else if (comment.type === 'thread') {
                        const lineInfo = comment.line ? `:${comment.line}` : '';
                        typeLabel = ` <span style="color: #666; font-size: 12px;">(${escapeHtml(comment.path)}${lineInfo})</span>`;
                    }
                    
                    const hiddenClass = comment.isHidden ? 'hidden auto-hidden' : '';
                    const resolvedClass = comment.isResolved ? 'hidden resolved-comment' : '';
                    const threadClass = comment.type === 'thread' ? 'thread-comment' : '';
                    
                    const manuallyHiddenKey = `${prIndex}-${idx}`;
                    const isManuallyHidden = hiddenComments[manuallyHiddenKey];
                    const manuallyHiddenClass = isManuallyHidden ? 'manually-hidden' : '';
                    const hideButtonText = isManuallyHidden ? 'Show' : 'Hide';
                    
                    // Add resolved indicator to type label if comment is resolved
                    let resolvedIndicator = '';
                    if (comment.isResolved) {
                        resolvedIndicator = ` <span style="color: #22863a; font-size: 11px; font-weight: 600;">‚úì [RESOLVED]</span>`;
                    }
                    
                    html += `
                        <div class="comment-item ${hiddenClass} ${resolvedClass} ${threadClass} ${manuallyHiddenClass}" data-pr-index="${prIndex}" data-comment-index="${idx}" data-is-resolved="${comment.isResolved}">
                            <div class="comment-header">
                                <span class="comment-author">${escapeHtml(comment.author)}</span>
                                ${typeLabel}
                                ${resolvedIndicator}
                                <span class="comment-date">${escapeHtml(date)}</span>
                                <button class="comment-hide-btn" onclick="toggleCommentVisibility(${prIndex}, ${idx})">${hideButtonText}</button>
                            </div>
                            <div class="comment-body">${escapeHtml(comment.body)}</div>
                        </div>
                    `;
                });
                html += '</div>';
            }
            
            // Store inline comments data for later use
            if (typeof window.inlineCommentsData === 'undefined') {
                window.inlineCommentsData = {};
            }
            window.inlineCommentsData[prIndex] = inlineComments;
            
            return html;
        }
        
        function toggleHiddenComments(prIndex) {
            const checkbox = document.getElementById(`hide-auto-${prIndex}`);
            const comments = document.querySelectorAll(`[data-pr-index="${prIndex}"].auto-hidden`);
            comments.forEach(comment => {
                if (checkbox.checked) {
                    comment.classList.add('hidden');
                } else {
                    comment.classList.remove('hidden');
                }
            });
        }
        
        function toggleResolvedComments(prIndex) {
            const checkbox = document.getElementById(`hide-resolved-${prIndex}`);
            const comments = document.querySelectorAll(`[data-pr-index="${prIndex}"].resolved-comment`);
            comments.forEach(comment => {
                if (checkbox.checked) {
                    comment.classList.add('hidden');
                } else {
                    comment.classList.remove('hidden');
                }
            });
            
            // Also refresh inline comments in diffs to reflect the change
            const showInlineCheckbox = document.getElementById(`show-inline-${prIndex}`);
            if (showInlineCheckbox && showInlineCheckbox.checked) {
                // Remove existing inline comments and re-add them with the new filter
                removeInlineCommentsFromDiff(prIndex);
                const inlineComments = window.inlineCommentsData[prIndex] || [];
                insertInlineCommentsIntoDiff(prIndex, inlineComments);
            }
        }
        
        function toggleInlineComments(prIndex) {
            const checkbox = document.getElementById(`show-inline-${prIndex}`);
            const inlineComments = window.inlineCommentsData[prIndex] || [];
            
            if (checkbox.checked) {
                // Show inline comments with diffs - we'll add them to the diff view
                insertInlineCommentsIntoDiff(prIndex, inlineComments);
            } else {
                // Remove inline comments from diff view
                removeInlineCommentsFromDiff(prIndex);
            }
        }
        
        function insertInlineCommentsIntoDiff(prIndex, inlineComments) {
            // Check if we should hide resolved threads
            const hideResolvedCheckbox = document.getElementById(`hide-resolved-${prIndex}`);
            const shouldHideResolved = hideResolvedCheckbox ? hideResolvedCheckbox.checked : false;
            
            // Filter out resolved comments if the hide resolved checkbox is checked
            const visibleComments = shouldHideResolved 
                ? inlineComments.filter(comment => !comment.isResolved)
                : inlineComments;
            
            // Group comments by file path
            const commentsByFile = {};
            visibleComments.forEach(comment => {
                if (!commentsByFile[comment.path]) {
                    commentsByFile[comment.path] = [];
                }
                commentsByFile[comment.path].push(comment);
            });
            
            // Find the diff container
            const diffContainer = document.getElementById(`diff-${prIndex}`);
            if (!diffContainer) return;
            
            // For each file with comments, try to insert them
            Object.keys(commentsByFile).forEach(filePath => {
                const comments = commentsByFile[filePath];
                
                // Find the file in the diff view
                const fileHeaders = diffContainer.querySelectorAll('.d2h-file-header');
                fileHeaders.forEach(header => {
                    const fileNameSpan = header.querySelector('.d2h-file-name');
                    if (fileNameSpan && fileNameSpan.textContent.includes(filePath)) {
                        // Found the file, add a comment section after the file wrapper
                        const fileWrapper = header.closest('.d2h-file-wrapper');
                        if (fileWrapper) {
                            let commentSection = fileWrapper.querySelector('.inline-comments-section');
                            if (!commentSection) {
                                commentSection = document.createElement('div');
                                commentSection.className = 'inline-comments-section';
                                commentSection.style.cssText = 'background: #fff3cd; border: 1px solid #ffc107; padding: 10px; margin: 10px 0; border-radius: 4px;';
                                
                                let commentsHtml = `<strong>üí¨ Comments on ${escapeHtml(filePath)}:</strong><br>`;
                                comments.forEach(comment => {
                                    const date = new Date(comment.createdAt).toLocaleString();
                                    const lineInfo = comment.line ? ` on line ${comment.line}` : '';
                                    const resolvedBadge = comment.isResolved ? ` <span style="color: #22863a; font-size: 11px; font-weight: 600;">‚úì [RESOLVED]</span>` : '';
                                    commentsHtml += `
                                        <div style="margin: 10px 0; padding: 10px; background: white; border-radius: 4px;">
                                            <div style="font-weight: 600; margin-bottom: 5px;">
                                                ${escapeHtml(comment.author)}${lineInfo}${resolvedBadge} <span style="color: #666; font-weight: normal; font-size: 12px;">${escapeHtml(date)}</span>
                                            </div>
                                            <div style="white-space: pre-wrap;">${escapeHtml(comment.body)}</div>
                                        </div>
                                    `;
                                });
                                commentSection.innerHTML = commentsHtml;
                                fileWrapper.appendChild(commentSection);
                            }
                        }
                    }
                });
            });
        }
        
        function removeInlineCommentsFromDiff(prIndex) {
            const diffContainer = document.getElementById(`diff-${prIndex}`);
            if (!diffContainer) return;
            
            const inlineSections = diffContainer.querySelectorAll('.inline-comments-section');
            inlineSections.forEach(section => section.remove());
        }
        
        async function submitComment(owner, repo, prNumber, prIndex) {
            const pat = getPAT();
            if (!pat) {
                showCommentStatus(prIndex, 'Please save your GitHub PAT first', 'error');
                return;
            }
            
            const commentText = document.getElementById(`comment-text-${prIndex}`).value.trim();
            if (!commentText) {
                showCommentStatus(prIndex, 'Please enter a comment', 'error');
                return;
            }
            
            try {
                const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/issues/${prNumber}/comments`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${pat}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/vnd.github.v3+json'
                    },
                    body: JSON.stringify({
                        body: commentText
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message || `Failed to post comment: ${response.status}`);
                }
                
                document.getElementById(`comment-text-${prIndex}`).value = '';
                showCommentStatus(prIndex, 'Comment posted successfully! Reload to see it.', 'success');
            } catch (error) {
                showCommentStatus(prIndex, `Error posting comment: ${error.message}`, 'error');
            }
        }
        
        async function approvePR(owner, repo, prNumber, prIndex) {
            const pat = getPAT();
            if (!pat) {
                showCommentStatus(prIndex, 'Please save your GitHub PAT first', 'error');
                return;
            }
            
            const commentText = document.getElementById(`comment-text-${prIndex}`).value.trim();
            
            try {
                const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/pulls/${prNumber}/reviews`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${pat}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/vnd.github.v3+json'
                    },
                    body: JSON.stringify({
                        event: 'APPROVE',
                        body: commentText || 'Approved via GitHub PR Combiner'
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message || `Failed to approve PR: ${response.status}`);
                }
                
                document.getElementById(`comment-text-${prIndex}`).value = '';
                showCommentStatus(prIndex, 'PR approved successfully! Reload to see the review.', 'success');
            } catch (error) {
                showCommentStatus(prIndex, `Error approving PR: ${error.message}`, 'error');
            }
        }
        
        function showCommentStatus(prIndex, message, type) {
            const statusDiv = document.getElementById(`comment-status-${prIndex}`);
            statusDiv.className = type === 'error' ? 'error-message' : 'success-message';
            statusDiv.textContent = message;
            
            // Clear the message after 5 seconds
            setTimeout(() => {
                statusDiv.textContent = '';
                statusDiv.className = '';
            }, 5000);
        }

        function showError(message) {
            const container = document.getElementById('error-container');
            container.innerHTML = `<div class="error">${escapeHtml(message)}</div>`;
        }
    </script>
</body>
</html>
