<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub PR Combiner</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: #24292e;
            color: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
        }
        
        header h1 {
            margin-bottom: 10px;
        }
        
        .auth-section {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .auth-section label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .auth-section input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .auth-section button {
            background: #2ea44f;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }
        
        .auth-section button:hover {
            background: #2c974b;
        }
        
        .auth-section .status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
        }
        
        .auth-section .status.success {
            background: #d4edda;
            color: #155724;
        }
        
        .auth-section .status.error {
            background: #f8d7da;
            color: #721c24;
        }
        
        .pr-form {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .pr-form h2 {
            margin-bottom: 15px;
        }
        
        .pr-form label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .pr-form input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .pr-form .help-text {
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
        }
        
        .pr-form button {
            background: #0366d6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            margin-right: 10px;
        }
        
        .pr-form button:hover {
            background: #0256c7;
        }
        
        .pr-list {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .pr-list h2 {
            margin-bottom: 15px;
        }
        
        .pr-item {
            display: flex;
            align-items: center;
            padding: 10px;
            background: #f6f8fa;
            margin-bottom: 8px;
            border-radius: 4px;
        }
        
        .pr-item span {
            flex: 1;
            font-family: monospace;
            font-size: 14px;
        }
        
        .pr-item a {
            margin-right: 10px;
            color: #0366d6;
            text-decoration: none;
            font-weight: 600;
            font-size: 14px;
        }
        
        .pr-item a:hover {
            text-decoration: underline;
        }
        
        .pr-item .approval-badge {
            margin-left: 10px;
            margin-right: 10px;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .pr-item .approval-badge.approved {
            background: #d4edda;
            color: #155724;
        }
        
        .pr-item .approval-badge.not-approved {
            background: #f8f9fa;
            color: #666;
        }
        
        .pr-item button {
            background: #d73a49;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .pr-item button:hover {
            background: #cb2431;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .loading::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }
        
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
        
        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        
        .pr-section {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .pr-header {
            border-bottom: 2px solid #e1e4e8;
            padding-bottom: 15px;
            margin-bottom: 20px;
        }
        
        .pr-header h2 {
            color: #0366d6;
            margin-bottom: 8px;
        }
        
        .pr-meta {
            font-size: 14px;
            color: #666;
        }
        
        .pr-meta span {
            margin-right: 15px;
        }
        
        .diff-container {
            margin-top: 20px;
        }
        
        .no-prs {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        
        .comments-section {
            margin-top: 30px;
            border-top: 2px solid #e1e4e8;
            padding-top: 20px;
        }
        
        .comments-section h3 {
            margin-bottom: 15px;
            color: #24292e;
        }
        
        .comment-item {
            background: #f6f8fa;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
            position: relative;
        }
        
        .comment-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .comment-author {
            font-weight: 600;
            margin-right: 10px;
        }
        
        .comment-date {
            color: #666;
            font-size: 12px;
            flex: 1;
        }
        
        .comment-hide-btn {
            background: #6a737d;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            margin-left: 10px;
        }
        
        .comment-hide-btn:hover {
            background: #586069;
        }
        
        .comment-body {
            line-height: 1.6;
            color: #24292e;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .comment-form {
            background: #f6f8fa;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .comment-form textarea {
            width: 100%;
            min-height: 100px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            font-size: 14px;
            resize: vertical;
            margin-bottom: 10px;
        }
        
        .comment-form button {
            background: #2ea44f;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            margin-right: 10px;
        }
        
        .comment-form button:hover {
            background: #2c974b;
        }
        
        .comment-form button.approve-btn {
            background: #0366d6;
        }
        
        .comment-form button.approve-btn:hover {
            background: #0256c7;
        }
        
        .no-comments {
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
        }
        
        .action-buttons {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e1e4e8;
        }
        
        .action-buttons button {
            background: #0366d6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            margin-right: 10px;
        }
        
        .action-buttons button:hover {
            background: #0256c7;
        }
        
        .action-buttons button.approve-btn {
            background: #2ea44f;
        }
        
        .action-buttons button.approve-btn:hover {
            background: #2c974b;
        }
        
        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }
        
        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }
        
        .comment-item.hidden {
            display: none;
        }
        
        .comment-item.manually-hidden .comment-body {
            display: none;
        }
        
        .comment-item.manually-hidden {
            background: #f1f3f5;
            padding: 10px 15px;
        }
        
        .comments-filter {
            margin-bottom: 15px;
            padding: 10px;
            background: #f6f8fa;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .comments-filter label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
            cursor: pointer;
        }
        
        .comments-filter input[type="checkbox"] {
            cursor: pointer;
        }
        
        .user-approval-status {
            background: #d4edda;
            color: #155724;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        .jump-to-top {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #0366d6;
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s;
        }
        
        .jump-to-top:hover {
            background: #0256c7;
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
        }
        
        .pr-general-status {
            margin-left: 10px;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }
        
        .pr-general-status.approved-state {
            background: #d4edda;
            color: #155724;
        }
        
        .pr-general-status.mixed-state {
            background: #fff3cd;
            color: #856404;
        }
        
        .pr-general-status.no-reviews {
            background: #f8f9fa;
            color: #666;
        }
        
        .pr-state-badge {
            margin-left: 10px;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .pr-state-badge.open {
            background: #dcffe4;
            color: #0e6027;
        }
        
        .pr-state-badge.merged {
            background: #e1e4e8;
            color: #6a737d;
        }
        
        .pr-state-badge.closed {
            background: #ffeef0;
            color: #d73a49;
        }
        
        /* Sticky File Explorer Styles */
        .diff-container {
            display: flex;
            gap: 20px;
            position: relative;
        }
        
        /* Make the file list sticky on the left side */
        .diff-container .d2h-file-list-wrapper {
            position: sticky;
            top: 20px;
            align-self: flex-start;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            flex-shrink: 0;
            width: 280px;
            background: white;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        /* Style the file list */
        .diff-container .d2h-file-list {
            margin: 0;
            padding: 0;
        }
        
        /* File list items */
        .diff-container .d2h-file-list-line {
            padding: 6px 8px;
            margin-bottom: 2px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .diff-container .d2h-file-list-line:hover {
            background-color: #f6f8fa;
        }
        
        .diff-container .d2h-file-list-line a {
            text-decoration: none;
            color: #0366d6;
            font-size: 13px;
            word-break: break-all;
        }
        
        .diff-container .d2h-file-list-line a:hover {
            text-decoration: underline;
        }
        
        /* Ensure the diff content takes remaining space */
        .diff-container .d2h-files-diff {
            flex: 1;
            min-width: 0;
        }
        
        /* Smooth scroll behavior for anchor links */
        html {
            scroll-behavior: smooth;
        }
        
        /* Add a header to the file list */
        .diff-container .d2h-file-list-wrapper::before {
            content: "📁 Files Changed";
            display: block;
            font-weight: 600;
            font-size: 14px;
            color: #24292e;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e1e4e8;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>🔀 GitHub PR Combiner</h1>
            <p>Combine multiple GitHub Pull Requests for review</p>
        </header>

        <div class="auth-section">
            <label for="pat-input">GitHub Personal Access Token</label>
            <input 
                type="password" 
                id="pat-input" 
                placeholder="ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
                autocomplete="off"
            >
            <button onclick="savePAT()">Save Token</button>
            <button onclick="clearPAT()" style="background: #d73a49;">Clear Token</button>
            <div id="auth-status"></div>
        </div>

        <div class="pr-form">
            <h2>Add Pull Request</h2>
            <label for="pr-url-input">PR URL or path</label>
            <input 
                type="text" 
                id="pr-url-input" 
                placeholder="https://github.com/owner/repo/pull/123 or owner/repo/pull/123"
            >
            <div class="help-text">
                Enter a GitHub PR URL or path in the format: owner/repo/pull/number
            </div>
            <button onclick="addPR()">Add PR</button>
            <button onclick="loadPRs()" style="background: #2ea44f;">Load PRs</button>
        </div>

        <div class="pr-list">
            <h2>Current PRs</h2>
            <div id="pr-list-container">
                <div class="no-prs">No PRs added yet</div>
            </div>
        </div>

        <div id="loading-indicator" style="display: none;" class="loading">
            Loading PR data
        </div>

        <div id="error-container"></div>
        <div id="pr-data-container"></div>
    </div>
    
    <!-- Jump to Top button -->
    <button class="jump-to-top" onclick="scrollToTop()" title="Jump to top" aria-label="Jump to top">
        ↑
    </button>

    <script src="https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js"></script>
    <script>
        const PAT_KEY = 'github_pat';
        const HIDDEN_COMMENTS_KEY = 'hidden_comments';
        let prDataCache = null;
        
        // Security: HTML escape function to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Scroll to top function
        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }
        
        // Hidden comments management
        function getHiddenComments() {
            const stored = localStorage.getItem(HIDDEN_COMMENTS_KEY);
            return stored ? JSON.parse(stored) : {};
        }
        
        function saveHiddenComments(hiddenComments) {
            localStorage.setItem(HIDDEN_COMMENTS_KEY, JSON.stringify(hiddenComments));
        }
        
        function toggleCommentVisibility(prIndex, commentIndex) {
            const hiddenComments = getHiddenComments();
            const key = `${prIndex}-${commentIndex}`;
            
            if (hiddenComments[key]) {
                delete hiddenComments[key];
            } else {
                hiddenComments[key] = true;
            }
            
            saveHiddenComments(hiddenComments);
            
            // Update UI
            const commentElement = document.querySelector(`[data-pr-index="${prIndex}"][data-comment-index="${commentIndex}"]`);
            if (commentElement) {
                const hideBtn = commentElement.querySelector('.comment-hide-btn');
                if (hiddenComments[key]) {
                    commentElement.classList.add('manually-hidden');
                    hideBtn.textContent = 'Show';
                } else {
                    commentElement.classList.remove('manually-hidden');
                    hideBtn.textContent = 'Hide';
                }
            }
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            checkPATStatus();
            loadPRsFromURL();
        });

        // PAT Management
        function savePAT() {
            const pat = document.getElementById('pat-input').value.trim();
            if (!pat) {
                showAuthStatus('Please enter a valid token', 'error');
                return;
            }
            
            localStorage.setItem(PAT_KEY, pat);
            document.getElementById('pat-input').value = '';
            showAuthStatus('Token saved successfully!', 'success');
        }

        function clearPAT() {
            localStorage.removeItem(PAT_KEY);
            showAuthStatus('Token cleared', 'success');
        }

        function getPAT() {
            return localStorage.getItem(PAT_KEY);
        }

        function checkPATStatus() {
            const pat = getPAT();
            if (pat) {
                showAuthStatus('Token is saved ✓', 'success');
            } else {
                showAuthStatus('No token saved. Please add your GitHub PAT.', 'error');
            }
        }

        function showAuthStatus(message, type) {
            const statusDiv = document.getElementById('auth-status');
            statusDiv.className = 'status ' + type;
            statusDiv.textContent = message;
        }

        // PR URL Management
        function parsePRPath(input) {
            // Handle full URL: https://github.com/owner/repo/pull/123
            const urlMatch = input.match(/github\.com\/([^\/]+)\/([^\/]+)\/pull\/(\d+)/);
            if (urlMatch) {
                return `${urlMatch[1]}/${urlMatch[2]}/pull/${urlMatch[3]}`;
            }
            
            // Handle path format: owner/repo/pull/123
            const pathMatch = input.match(/^([^\/]+)\/([^\/]+)\/pull\/(\d+)$/);
            if (pathMatch) {
                return input;
            }
            
            return null;
        }

        function getPRsFromURL() {
            const params = new URLSearchParams(window.location.search);
            const prsParam = params.get('prs');
            if (!prsParam) return [];
            
            return prsParam.split(',').filter(pr => pr.trim());
        }

        function updateURL(prs) {
            const params = new URLSearchParams();
            if (prs.length > 0) {
                params.set('prs', prs.join(','));
            }
            
            const newURL = params.toString() 
                ? `${window.location.pathname}?${params.toString()}`
                : window.location.pathname;
            
            window.history.pushState({}, '', newURL);
        }

        function addPR() {
            const input = document.getElementById('pr-url-input').value.trim();
            if (!input) {
                alert('Please enter a PR URL or path');
                return;
            }

            const prPath = parsePRPath(input);
            if (!prPath) {
                alert('Invalid PR format. Use: owner/repo/pull/123');
                return;
            }

            const currentPRs = getPRsFromURL();
            if (currentPRs.includes(prPath)) {
                alert('This PR is already in the list');
                return;
            }

            currentPRs.push(prPath);
            updateURL(currentPRs);
            document.getElementById('pr-url-input').value = '';
            renderPRList();
        }

        function removePR(prPath) {
            const currentPRs = getPRsFromURL();
            const filtered = currentPRs.filter(pr => pr !== prPath);
            updateURL(filtered);
            renderPRList();
            
            // Clear PR data if we removed all PRs
            if (filtered.length === 0) {
                document.getElementById('pr-data-container').innerHTML = '';
            }
        }

        function renderPRList() {
            const prs = getPRsFromURL();
            const container = document.getElementById('pr-list-container');
            
            if (prs.length === 0) {
                container.innerHTML = '<div class="no-prs">No PRs added yet</div>';
                return;
            }

            // If we have cached PR data, show approval status
            let html = '';
            prs.forEach((pr, index) => {
                let approvalBadge = '';
                let generalStatusBadge = '';
                let stateBadge = '';
                
                if (prDataCache && prDataCache[index]) {
                    const prData = prDataCache[index];
                    
                    // PR State badge
                    const state = prData.info.state.toLowerCase();
                    stateBadge = `<span class="pr-state-badge ${state}">${prData.info.state}</span>`;
                    
                    // Calculate general PR status
                    let approvalCount = 0;
                    let changesRequestedCount = 0;
                    let viewerApproved = false;
                    
                    if (prData.info.reviews && prData.info.reviews.nodes) {
                        // Count approvals and changes requested
                        const reviewsByAuthor = {};
                        prData.info.reviews.nodes.forEach(review => {
                            // Keep only the latest review from each author
                            if (!reviewsByAuthor[review.author.login] || 
                                new Date(review.createdAt) > new Date(reviewsByAuthor[review.author.login].createdAt)) {
                                reviewsByAuthor[review.author.login] = review;
                            }
                        });
                        
                        Object.values(reviewsByAuthor).forEach(review => {
                            if (review.state === 'APPROVED') {
                                approvalCount++;
                            } else if (review.state === 'CHANGES_REQUESTED') {
                                changesRequestedCount++;
                            }
                        });
                        
                        if (prData.viewerLogin) {
                            viewerApproved = reviewsByAuthor[prData.viewerLogin]?.state === 'APPROVED';
                        }
                    }
                    
                    // User's personal approval status
                    if (viewerApproved) {
                        approvalBadge = '<span class="approval-badge approved">✓ Approved</span>';
                    } else {
                        approvalBadge = '<span class="approval-badge not-approved">Not approved</span>';
                    }
                    
                    // General PR status
                    if (approvalCount > 0 || changesRequestedCount > 0) {
                        const approvalText = approvalCount > 0 ? `${approvalCount}✓` : '';
                        const changesText = changesRequestedCount > 0 ? `${changesRequestedCount}⚠` : '';
                        const separator = approvalText && changesText ? ' ' : '';
                        const statusClass = approvalCount > 0 && changesRequestedCount === 0 ? 'approved-state' : 
                                          (changesRequestedCount > 0 ? 'mixed-state' : 'no-reviews');
                        
                        generalStatusBadge = `<span class="pr-general-status ${statusClass}">${approvalText}${separator}${changesText}</span>`;
                    } else {
                        generalStatusBadge = '<span class="pr-general-status no-reviews">No reviews</span>';
                    }
                }
                
                html += `
                    <div class="pr-item">
                        <a href="#pr-${index}">Jump to PR</a>
                        <span>${escapeHtml(pr)}</span>
                        ${stateBadge}
                        ${generalStatusBadge}
                        ${approvalBadge}
                        <button onclick="removePR('${escapeHtml(pr)}')">Remove</button>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        function loadPRsFromURL() {
            renderPRList();
        }

        // GitHub GraphQL API
        async function loadPRs() {
            const pat = getPAT();
            if (!pat) {
                showError('Please save your GitHub Personal Access Token first.');
                return;
            }

            const prs = getPRsFromURL();
            if (prs.length === 0) {
                showError('Please add at least one PR to load.');
                return;
            }

            document.getElementById('loading-indicator').style.display = 'block';
            document.getElementById('error-container').innerHTML = '';
            document.getElementById('pr-data-container').innerHTML = '';

            try {
                const prData = await fetchPRData(pat, prs);
                renderPRData(prData);
            } catch (error) {
                showError(`Error loading PRs: ${error.message}`);
            } finally {
                document.getElementById('loading-indicator').style.display = 'none';
            }
        }

        async function fetchPRData(pat, prPaths) {
            // Build GraphQL query with aliases for each PR
            const queries = prPaths.map((prPath, index) => {
                const parts = prPath.split('/');
                const owner = parts[0];
                const repo = parts[1];
                const number = parseInt(parts[3]);
                
                return `
                    pr${index}: repository(owner: "${owner}", name: "${repo}") {
                        pullRequest(number: ${number}) {
                            title
                            number
                            url
                            author {
                                login
                            }
                            baseRefName
                            headRefName
                            state
                            createdAt
                            updatedAt
                            additions
                            deletions
                            changedFiles
                            comments(first: 100) {
                                nodes {
                                    author {
                                        login
                                    }
                                    body
                                    createdAt
                                    updatedAt
                                }
                            }
                            reviews(first: 100) {
                                nodes {
                                    author {
                                        login
                                    }
                                    body
                                    state
                                    createdAt
                                    comments(first: 100) {
                                        nodes {
                                            author {
                                                login
                                            }
                                            body
                                            path
                                            position
                                            originalPosition
                                            line
                                            originalLine
                                            createdAt
                                        }
                                    }
                                }
                            }
                        }
                    }
                `;
            });

            const query = `
                query {
                    viewer {
                        login
                    }
                    ${queries.join('\n')}
                }
            `;

            const response = await fetch('https://api.github.com/graphql', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${pat}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ query })
            });

            if (!response.ok) {
                throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
            }

            const result = await response.json();
            
            if (result.errors) {
                throw new Error(result.errors[0].message);
            }

            const viewerLogin = result.data.viewer ? result.data.viewer.login : null;

            // Fetch diffs for each PR
            const prDataWithDiffs = [];
            for (let i = 0; i < prPaths.length; i++) {
                const prData = result.data[`pr${i}`];
                if (!prData || !prData.pullRequest) {
                    throw new Error(`PR not found: ${prPaths[i]}`);
                }

                const parts = prPaths[i].split('/');
                const owner = parts[0];
                const repo = parts[1];
                const number = parseInt(parts[3]);
                
                const diff = await fetchPRDiff(pat, owner, repo, number);
                
                prDataWithDiffs.push({
                    path: prPaths[i],
                    info: prData.pullRequest,
                    diff: diff,
                    owner: owner,
                    repo: repo,
                    viewerLogin: viewerLogin
                });
            }

            return prDataWithDiffs;
        }

        async function fetchPRDiff(pat, owner, repo, number) {
            const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/pulls/${number}`, {
                headers: {
                    'Authorization': `Bearer ${pat}`,
                    'Accept': 'application/vnd.github.v3.diff'
                }
            });

            if (!response.ok) {
                throw new Error(`Failed to fetch diff: ${response.status}`);
            }

            return await response.text();
        }

        function renderPRData(prDataArray) {
            const container = document.getElementById('pr-data-container');
            container.innerHTML = '';
            
            // Cache the PR data for use in the PR list
            prDataCache = prDataArray;
            
            // Re-render the PR list to show approval status
            renderPRList();

            prDataArray.forEach((prData, index) => {
                const section = document.createElement('div');
                section.className = 'pr-section';
                section.id = `pr-${index}`;

                // Check if viewer has approved this PR
                let viewerApproved = false;
                let prHasApprovals = false;
                let approvalCount = 0;
                let changesRequestedCount = 0;
                
                if (prData.info.reviews && prData.info.reviews.nodes) {
                    // Count approvals and changes requested
                    const reviewsByAuthor = {};
                    prData.info.reviews.nodes.forEach(review => {
                        // Keep only the latest review from each author
                        if (!reviewsByAuthor[review.author.login] || 
                            new Date(review.createdAt) > new Date(reviewsByAuthor[review.author.login].createdAt)) {
                            reviewsByAuthor[review.author.login] = review;
                        }
                    });
                    
                    Object.values(reviewsByAuthor).forEach(review => {
                        if (review.state === 'APPROVED') {
                            approvalCount++;
                            prHasApprovals = true;
                        } else if (review.state === 'CHANGES_REQUESTED') {
                            changesRequestedCount++;
                        }
                    });
                    
                    if (prData.viewerLogin) {
                        viewerApproved = reviewsByAuthor[prData.viewerLogin]?.state === 'APPROVED';
                    }
                }

                const header = document.createElement('div');
                header.className = 'pr-header';
                
                let approvalBanner = '';
                if (viewerApproved) {
                    approvalBanner = '<div class="user-approval-status" style="margin-bottom: 15px;">✓ You have approved this PR</div>';
                }
                
                // Add overall PR approval state
                let prStateBanner = '';
                if (approvalCount > 0 || changesRequestedCount > 0) {
                    const approvalText = approvalCount > 0 ? `${approvalCount} approval${approvalCount > 1 ? 's' : ''}` : '';
                    const changesText = changesRequestedCount > 0 ? `${changesRequestedCount} change${changesRequestedCount > 1 ? 's' : ''} requested` : '';
                    const separator = approvalText && changesText ? ', ' : '';
                    const stateColor = prHasApprovals && changesRequestedCount === 0 ? '#d4edda' : (changesRequestedCount > 0 ? '#fff3cd' : '#f8f9fa');
                    const textColor = prHasApprovals && changesRequestedCount === 0 ? '#155724' : (changesRequestedCount > 0 ? '#856404' : '#666');
                    
                    prStateBanner = `<div style="background: ${stateColor}; color: ${textColor}; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-weight: 600;">
                        PR Status: ${approvalText}${separator}${changesText}
                    </div>`;
                }
                
                header.innerHTML = `
                    <h2>${escapeHtml(prData.info.title)} <a href="${escapeHtml(prData.info.url)}" target="_blank">#${prData.info.number}</a></h2>
                    ${prStateBanner}
                    ${approvalBanner}
                    <div class="pr-meta">
                        <span><strong>Author:</strong> ${escapeHtml(prData.info.author.login)}</span>
                        <span><strong>State:</strong> ${escapeHtml(prData.info.state)}</span>
                        <span><strong>Branch:</strong> ${escapeHtml(prData.info.headRefName)} → ${escapeHtml(prData.info.baseRefName)}</span>
                        <span><strong>Changes:</strong> +${prData.info.additions} -${prData.info.deletions} (${prData.info.changedFiles} files)</span>
                    </div>
                `;

                const diffContainer = document.createElement('div');
                diffContainer.className = 'diff-container';
                diffContainer.id = `diff-${index}`;

                // Comments section
                const commentsSection = document.createElement('div');
                commentsSection.className = 'comments-section';
                commentsSection.innerHTML = renderComments(prData.info, index, prData.viewerLogin);

                // Comment form
                const commentForm = document.createElement('div');
                commentForm.className = 'comment-form';
                commentForm.innerHTML = `
                    <h4>Add a comment</h4>
                    <textarea id="comment-text-${index}" placeholder="Leave a comment..."></textarea>
                    <div id="comment-status-${index}"></div>
                    <button onclick="submitComment('${escapeHtml(prData.owner)}', '${escapeHtml(prData.repo)}', ${prData.info.number}, ${index})">Comment</button>
                    <button class="approve-btn" onclick="approvePR('${escapeHtml(prData.owner)}', '${escapeHtml(prData.repo)}', ${prData.info.number}, ${index})">Approve PR</button>
                `;

                section.appendChild(header);
                section.appendChild(diffContainer);
                section.appendChild(commentsSection);
                section.appendChild(commentForm);
                container.appendChild(section);

                // Render diff using diff2html
                try {
                    const diff2htmlUi = new Diff2HtmlUI(diffContainer, prData.diff, {
                        drawFileList: true,
                        matching: 'lines',
                        outputFormat: 'side-by-side',
                        synchronisedScroll: true,
                        highlight: true,
                        renderNothingWhenEmpty: false,
                    });
                    diff2htmlUi.draw();
                } catch (error) {
                    diffContainer.innerHTML = `<div class="error">Error rendering diff: ${error.message}</div>`;
                }
                
                // Show inline comments by default since checkbox is checked by default
                setTimeout(() => toggleInlineComments(index), 100);
            });
        }
        
        function renderComments(prInfo, prIndex, viewerLogin) {
            const hiddenUsers = ['simonirwin-r7', 'compliance-r7', 'pd-sonarqube-r7'];
            const hiddenComments = getHiddenComments();
            let html = '<h3>Comments and Reviews</h3>';
            
            // Add filter controls
            html += `
                <div class="comments-filter">
                    <label>
                        <input type="checkbox" id="hide-auto-${prIndex}" onchange="toggleHiddenComments(${prIndex})" checked>
                        Hide automated comments (simonirwin-r7, compliance-r7, pd-sonarqube-r7)
                    </label>
                    <label>
                        <input type="checkbox" id="show-inline-${prIndex}" onchange="toggleInlineComments(${prIndex})" checked>
                        Show inline comments with diffs
                    </label>
                </div>
            `;
            
            const allComments = [];
            const inlineComments = [];
            
            // Add issue comments
            if (prInfo.comments && prInfo.comments.nodes) {
                prInfo.comments.nodes.forEach(comment => {
                    allComments.push({
                        type: 'comment',
                        author: comment.author.login,
                        body: comment.body,
                        createdAt: comment.createdAt,
                        isHidden: hiddenUsers.includes(comment.author.login)
                    });
                });
            }
            
            // Add review comments
            if (prInfo.reviews && prInfo.reviews.nodes) {
                prInfo.reviews.nodes.forEach(review => {
                    if (review.body) {
                        allComments.push({
                            type: 'review',
                            author: review.author.login,
                            body: review.body,
                            state: review.state,
                            createdAt: review.createdAt,
                            isHidden: hiddenUsers.includes(review.author.login)
                        });
                    }
                    
                    // Add inline review comments
                    if (review.comments && review.comments.nodes) {
                        review.comments.nodes.forEach(comment => {
                            const inlineComment = {
                                type: 'inline',
                                author: comment.author.login,
                                body: comment.body,
                                path: comment.path,
                                position: comment.position,
                                originalPosition: comment.originalPosition,
                                line: comment.line,
                                originalLine: comment.originalLine,
                                createdAt: comment.createdAt,
                                isHidden: hiddenUsers.includes(comment.author.login)
                            };
                            allComments.push(inlineComment);
                            inlineComments.push(inlineComment);
                        });
                    }
                });
            }
            
            // Sort by date
            allComments.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
            
            if (allComments.length === 0) {
                html += '<div class="no-comments">No comments yet</div>';
            } else {
                html += `<div id="comments-list-${prIndex}">`;
                allComments.forEach((comment, idx) => {
                    const date = new Date(comment.createdAt).toLocaleString();
                    let typeLabel = '';
                    
                    if (comment.type === 'review') {
                        typeLabel = ` <span style="color: #0366d6; font-weight: 600;">[${comment.state}]</span>`;
                    } else if (comment.type === 'inline') {
                        const lineInfo = comment.line ? `:${comment.line}` : '';
                        typeLabel = ` <span style="color: #666; font-size: 12px;">(${escapeHtml(comment.path)}${lineInfo})</span>`;
                    }
                    
                    const hiddenClass = comment.isHidden ? 'hidden auto-hidden' : '';
                    const inlineClass = comment.type === 'inline' ? 'inline-comment' : '';
                    
                    const manuallyHiddenKey = `${prIndex}-${idx}`;
                    const isManuallyHidden = hiddenComments[manuallyHiddenKey];
                    const manuallyHiddenClass = isManuallyHidden ? 'manually-hidden' : '';
                    const hideButtonText = isManuallyHidden ? 'Show' : 'Hide';
                    
                    html += `
                        <div class="comment-item ${hiddenClass} ${inlineClass} ${manuallyHiddenClass}" data-pr-index="${prIndex}" data-comment-index="${idx}">
                            <div class="comment-header">
                                <span class="comment-author">${escapeHtml(comment.author)}</span>
                                ${typeLabel}
                                <span class="comment-date">${escapeHtml(date)}</span>
                                <button class="comment-hide-btn" onclick="toggleCommentVisibility(${prIndex}, ${idx})">${hideButtonText}</button>
                            </div>
                            <div class="comment-body">${escapeHtml(comment.body)}</div>
                        </div>
                    `;
                });
                html += '</div>';
            }
            
            // Store inline comments data for later use
            if (typeof window.inlineCommentsData === 'undefined') {
                window.inlineCommentsData = {};
            }
            window.inlineCommentsData[prIndex] = inlineComments;
            
            return html;
        }
        
        function toggleHiddenComments(prIndex) {
            const checkbox = document.getElementById(`hide-auto-${prIndex}`);
            const comments = document.querySelectorAll(`[data-pr-index="${prIndex}"].auto-hidden`);
            comments.forEach(comment => {
                if (checkbox.checked) {
                    comment.classList.add('hidden');
                } else {
                    comment.classList.remove('hidden');
                }
            });
        }
        
        function toggleInlineComments(prIndex) {
            const checkbox = document.getElementById(`show-inline-${prIndex}`);
            const inlineComments = window.inlineCommentsData[prIndex] || [];
            
            if (checkbox.checked) {
                // Show inline comments with diffs - we'll add them to the diff view
                insertInlineCommentsIntoDiff(prIndex, inlineComments);
            } else {
                // Remove inline comments from diff view
                removeInlineCommentsFromDiff(prIndex);
            }
        }
        
        function insertInlineCommentsIntoDiff(prIndex, inlineComments) {
            // Group comments by file path
            const commentsByFile = {};
            inlineComments.forEach(comment => {
                if (!commentsByFile[comment.path]) {
                    commentsByFile[comment.path] = [];
                }
                commentsByFile[comment.path].push(comment);
            });
            
            // Find the diff container
            const diffContainer = document.getElementById(`diff-${prIndex}`);
            if (!diffContainer) return;
            
            // For each file with comments, try to insert them
            Object.keys(commentsByFile).forEach(filePath => {
                const comments = commentsByFile[filePath];
                
                // Find the file in the diff view
                const fileHeaders = diffContainer.querySelectorAll('.d2h-file-header');
                fileHeaders.forEach(header => {
                    const fileNameSpan = header.querySelector('.d2h-file-name');
                    if (fileNameSpan && fileNameSpan.textContent.includes(filePath)) {
                        // Found the file, add a comment section after the file wrapper
                        const fileWrapper = header.closest('.d2h-file-wrapper');
                        if (fileWrapper) {
                            let commentSection = fileWrapper.querySelector('.inline-comments-section');
                            if (!commentSection) {
                                commentSection = document.createElement('div');
                                commentSection.className = 'inline-comments-section';
                                commentSection.style.cssText = 'background: #fff3cd; border: 1px solid #ffc107; padding: 10px; margin: 10px 0; border-radius: 4px;';
                                
                                let commentsHtml = `<strong>💬 Comments on ${escapeHtml(filePath)}:</strong><br>`;
                                comments.forEach(comment => {
                                    const date = new Date(comment.createdAt).toLocaleString();
                                    const lineInfo = comment.line ? ` on line ${comment.line}` : '';
                                    commentsHtml += `
                                        <div style="margin: 10px 0; padding: 10px; background: white; border-radius: 4px;">
                                            <div style="font-weight: 600; margin-bottom: 5px;">
                                                ${escapeHtml(comment.author)}${lineInfo} <span style="color: #666; font-weight: normal; font-size: 12px;">${escapeHtml(date)}</span>
                                            </div>
                                            <div style="white-space: pre-wrap;">${escapeHtml(comment.body)}</div>
                                        </div>
                                    `;
                                });
                                commentSection.innerHTML = commentsHtml;
                                fileWrapper.appendChild(commentSection);
                            }
                        }
                    }
                });
            });
        }
        
        function removeInlineCommentsFromDiff(prIndex) {
            const diffContainer = document.getElementById(`diff-${prIndex}`);
            if (!diffContainer) return;
            
            const inlineSections = diffContainer.querySelectorAll('.inline-comments-section');
            inlineSections.forEach(section => section.remove());
        }
        
        async function submitComment(owner, repo, prNumber, prIndex) {
            const pat = getPAT();
            if (!pat) {
                showCommentStatus(prIndex, 'Please save your GitHub PAT first', 'error');
                return;
            }
            
            const commentText = document.getElementById(`comment-text-${prIndex}`).value.trim();
            if (!commentText) {
                showCommentStatus(prIndex, 'Please enter a comment', 'error');
                return;
            }
            
            try {
                const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/issues/${prNumber}/comments`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${pat}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/vnd.github.v3+json'
                    },
                    body: JSON.stringify({
                        body: commentText
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message || `Failed to post comment: ${response.status}`);
                }
                
                document.getElementById(`comment-text-${prIndex}`).value = '';
                showCommentStatus(prIndex, 'Comment posted successfully! Reload to see it.', 'success');
            } catch (error) {
                showCommentStatus(prIndex, `Error posting comment: ${error.message}`, 'error');
            }
        }
        
        async function approvePR(owner, repo, prNumber, prIndex) {
            const pat = getPAT();
            if (!pat) {
                showCommentStatus(prIndex, 'Please save your GitHub PAT first', 'error');
                return;
            }
            
            const commentText = document.getElementById(`comment-text-${prIndex}`).value.trim();
            
            try {
                const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/pulls/${prNumber}/reviews`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${pat}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/vnd.github.v3+json'
                    },
                    body: JSON.stringify({
                        event: 'APPROVE',
                        body: commentText || 'Approved via GitHub PR Combiner'
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message || `Failed to approve PR: ${response.status}`);
                }
                
                document.getElementById(`comment-text-${prIndex}`).value = '';
                showCommentStatus(prIndex, 'PR approved successfully! Reload to see the review.', 'success');
            } catch (error) {
                showCommentStatus(prIndex, `Error approving PR: ${error.message}`, 'error');
            }
        }
        
        function showCommentStatus(prIndex, message, type) {
            const statusDiv = document.getElementById(`comment-status-${prIndex}`);
            statusDiv.className = type === 'error' ? 'error-message' : 'success-message';
            statusDiv.textContent = message;
            
            // Clear the message after 5 seconds
            setTimeout(() => {
                statusDiv.textContent = '';
                statusDiv.className = '';
            }, 5000);
        }

        function showError(message) {
            const container = document.getElementById('error-container');
            container.innerHTML = `<div class="error">${escapeHtml(message)}</div>`;
        }
    </script>
</body>
</html>
